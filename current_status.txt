npm webassembly (npm i -g webassembly@0.11.0) works perfectly with C code.

Emscripten works perfectly with C and C++ code but can't find C++ name-mangled functions (i.e. I have to wrap them with extern "C" { <cpp_function> }) 
(giving out this error when loaded in node: Assertion failed: Cannot call unknown function usingStdStringInternally (perhaps LLVM optimizations or closure removed it?)).

To avoid this C++ name mangling issue you have to declare the function prototype (for C and C++ code alike) like so:
    WASM_FUNCTION_EXPORT const char *usingStdStringInternally(const char *firstStr) asm("usingStdStringInternally");
With asm("<function_name>") at the end to give this function an exact name. Although, it is still necessary to use primitive types, that is,
a signature with C++ std types like std::string wont work. Emscripten generated js will find the function but won't give out anything.

Then define the function like this:
    const char *usingStdStringInternally(const char *firstStr)
    {
        return std::string(std::string(firstStr) + " added to this").c_str();
    }
As it is noticed, you can use std::string and C++ std types in the function body.

C code should only be compiled using npm webassembly module (wa compile).

It is not a good idea to mix C and C++ modules in emcc as it complains with a warning, but it is possible and you can do it
without further problems.
When compiling C modules in emcc, function signature also needs the asm("<function_name">) directive in the function prototype, if not done so
when loaded in node you will get this error: Assertion failed: Cannot call unknown function getTestStrC (perhaps LLVM optimizations or closure removed it?).